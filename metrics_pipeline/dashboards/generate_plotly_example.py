#!/usr/bin/env python3
"""
Plotly Dashboard Generator

This script reads CSV files generated by the metrics aggregation pipeline
and creates interactive HTML dashboards using Plotly.

Usage:
    python metrics_pipeline/dashboards/generate_plotly_example.py

Prerequisites:
    pip install plotly pandas  # Add to requirements.txt if enabling

This will:
1. Read CSV files from metrics_pipeline/csv/
2. Generate interactive line charts for time-series metrics
3. Create HTML dashboard files in metrics_pipeline/dashboards/
"""

import os
import sys
from pathlib import Path
import csv
import json
from datetime import datetime

try:
    import plotly.graph_objects as go
    import plotly.express as px
    from plotly.subplots import make_subplots
    import pandas as pd
    PLOTLY_AVAILABLE = True
except ImportError:
    PLOTLY_AVAILABLE = False
    print("INFO: Plotly/Pandas not available. Install with: pip install plotly pandas")


def read_csv_with_fallback(csv_path):
    """
    Read CSV file using standard library as fallback if pandas not available.
    
    Args:
        csv_path (str): Path to CSV file
        
    Returns:
        list: List of dictionaries representing rows
    """
    data = []
    try:
        with open(csv_path, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            data = list(reader)
    except Exception as e:
        print(f"Error reading {csv_path}: {e}")
        
    return data


def create_time_series_chart(data, title):
    """
    Create a time series chart from metrics data.
    
    Args:
        data (list): List of data records
        title (str): Chart title
        
    Returns:
        plotly.graph_objects.Figure: Plotly figure object
    """
    if not PLOTLY_AVAILABLE:
        return None
        
    # Filter records with timestamp and value
    time_series_data = []
    for record in data:
        if 'timestamp' in record and 'value' in record and 'metric_name' in record:
            try:
                timestamp = record['timestamp']
                value = float(record['value'])
                metric_name = record['metric_name']
                host = record.get('host', 'unknown')
                time_series_data.append({
                    'timestamp': timestamp,
                    'value': value,
                    'metric_name': metric_name,
                    'host': host
                })
            except (ValueError, TypeError):
                continue
    
    if not time_series_data:
        print(f"No time series data found for {title}")
        return None
    
    # Convert to pandas DataFrame for easier plotting
    df = pd.DataFrame(time_series_data)
    df['timestamp'] = pd.to_datetime(df['timestamp'])
    
    # Create figure with subplots for different metrics
    unique_metrics = df['metric_name'].unique()
    
    if len(unique_metrics) <= 4:
        # Single figure with multiple traces
        fig = go.Figure()
        
        for metric in unique_metrics:
            metric_data = df[df['metric_name'] == metric]
            
            for host in metric_data['host'].unique():
                host_data = metric_data[metric_data['host'] == host]
                
                fig.add_trace(go.Scatter(
                    x=host_data['timestamp'],
                    y=host_data['value'],
                    mode='lines+markers',
                    name=f"{metric} ({host})",
                    line=dict(width=2),
                    marker=dict(size=4)
                ))
        
        fig.update_layout(
            title=title,
            xaxis_title="Time",
            yaxis_title="Value",
            hovermode='x unified',
            template="plotly_white",
            height=600,
            showlegend=True
        )
        
    else:
        # Multiple subplots for many metrics
        fig = make_subplots(
            rows=2, cols=2,
            subplot_titles=list(unique_metrics[:4]),
            vertical_spacing=0.12,
            horizontal_spacing=0.1
        )
        
        positions = [(1, 1), (1, 2), (2, 1), (2, 2)]
        
        for i, metric in enumerate(unique_metrics[:4]):
            metric_data = df[df['metric_name'] == metric]
            row, col = positions[i]
            
            for host in metric_data['host'].unique():
                host_data = metric_data[metric_data['host'] == host]
                
                fig.add_trace(
                    go.Scatter(
                        x=host_data['timestamp'],
                        y=host_data['value'],
                        mode='lines+markers',
                        name=f"{metric} ({host})",
                        line=dict(width=2),
                        marker=dict(size=4),
                        showlegend=(i == 0)  # Only show legend for first subplot
                    ),
                    row=row, col=col
                )
        
        fig.update_layout(
            title=title,
            height=800,
            template="plotly_white",
            showlegend=True
        )
        
        # Update axis titles
        fig.update_xaxes(title_text="Time")
        fig.update_yaxes(title_text="Value")
    
    return fig


def create_summary_dashboard(summary_data):
    """
    Create a summary dashboard from summary statistics.
    
    Args:
        summary_data (list): Summary statistics data
        
    Returns:
        plotly.graph_objects.Figure: Plotly figure object
    """
    if not PLOTLY_AVAILABLE or not summary_data:
        return None
    
    # Extract metrics for visualization
    metrics_dict = {}
    for row in summary_data:
        if len(row) >= 2:
            metric, value = row[0], row[1]
            try:
                # Try to convert to number
                metrics_dict[metric] = float(value)
            except (ValueError, TypeError):
                metrics_dict[metric] = value
    
    # Create dashboard with multiple charts
    fig = make_subplots(
        rows=2, cols=2,
        specs=[[{"type": "indicator"}, {"type": "bar"}],
               [{"type": "pie", "colspan": 2}, None]],
        subplot_titles=("Key Metrics", "Processing Stats", "Metric Distribution"),
        vertical_spacing=0.15
    )
    
    # Key metrics indicators
    total_records = metrics_dict.get('total_records', 0)
    unique_metrics = metrics_dict.get('unique_metrics', 0)
    
    fig.add_trace(
        go.Indicator(
            mode="number+delta+gauge",
            value=total_records,
            title={"text": "Total Records"},
            number={"font": {"size": 40}},
            gauge={"axis": {"range": [0, total_records * 1.5]}},
            delta={"reference": total_records * 0.8}
        ),
        row=1, col=1
    )
    
    # Processing statistics bar chart
    processing_stats = {
        'Files': metrics_dict.get('total_files_processed', 0),
        'Metrics': unique_metrics,
        'Hosts': metrics_dict.get('unique_hosts', 0),
        'Environments': metrics_dict.get('unique_environments', 0)
    }
    
    fig.add_trace(
        go.Bar(
            x=list(processing_stats.keys()),
            y=list(processing_stats.values()),
            marker_color=['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'],
            name="Processing Stats"
        ),
        row=1, col=2
    )
    
    # Mock pie chart for metric distribution (you could enhance this with real data)
    metric_types = ['System', 'Application', 'Database', 'Network']
    values = [30, 25, 25, 20]  # Mock percentages
    
    fig.add_trace(
        go.Pie(
            labels=metric_types,
            values=values,
            marker_colors=['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'],
            name="Metrics by Type"
        ),
        row=2, col=1
    )
    
    fig.update_layout(
        title="Metrics Pipeline Dashboard",
        height=800,
        template="plotly_white",
        showlegend=False
    )
    
    return fig


def generate_dashboards():
    """
    Main function to generate Plotly dashboards from CSV data.
    
    Returns:
        tuple: (success boolean, results summary)
    """
    if not PLOTLY_AVAILABLE:
        print("ERROR: Plotly is not available. Install with: pip install plotly pandas")
        return False, "Missing dependencies"
    
    # Define paths
    script_dir = Path(__file__).parent
    csv_dir = script_dir.parent / 'csv'
    dashboard_dir = script_dir
    
    # Ensure dashboard directory exists
    dashboard_dir.mkdir(exist_ok=True)
    
    # Find CSV files
    csv_files = list(csv_dir.glob('*.csv'))
    
    if not csv_files:
        return False, f"No CSV files found in {csv_dir}"
    
    print(f"Found {len(csv_files)} CSV file(s) to process")
    
    dashboards_created = 0
    
    # Process each CSV file
    for csv_file in csv_files:
        if csv_file.name == 'summary_stats.csv':
            # Handle summary file specially
            print(f"Processing summary: {csv_file}")
            
            # Read summary data
            with open(csv_file, 'r') as f:
                reader = csv.reader(f)
                summary_data = list(reader)[1:]  # Skip header
            
            # Create summary dashboard
            fig = create_summary_dashboard(summary_data)
            if fig:
                output_path = dashboard_dir / 'summary_dashboard.html'
                fig.write_html(str(output_path))
                print(f"  Created: {output_path}")
                dashboards_created += 1
            
        else:
            # Handle regular metrics files
            print(f"Processing metrics: {csv_file}")
            
            # Read metrics data
            data = read_csv_with_fallback(str(csv_file))
            
            if data:
                # Create time series chart
                title = f"Metrics Dashboard - {csv_file.stem}"
                fig = create_time_series_chart(data, title)
                
                if fig:
                    output_path = dashboard_dir / f"{csv_file.stem}_dashboard.html"
                    fig.write_html(str(output_path))
                    print(f"  Created: {output_path}")
                    dashboards_created += 1
    
    results = f"Created {dashboards_created} dashboard(s)"
    print(f"\n=== Dashboard Generation Complete ===")
    print(results)
    
    return dashboards_created > 0, results


if __name__ == "__main__":
    if not PLOTLY_AVAILABLE:
        print("To enable Plotly dashboards:")
        print("1. Add 'plotly>=5.0.0' and 'pandas>=1.3.0' to requirements.txt")
        print("2. Run: pip install plotly pandas")
        print("3. Re-run this script")
        sys.exit(0)
    
    success, results = generate_dashboards()
    sys.exit(0 if success else 1)